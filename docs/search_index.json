[["index.html", "Geophysical Data Science with R Preface", " Geophysical Data Science with R Christopher Danek 02 February, 2021 Preface Hi This page collects examples how I process geophysical data with R. utils::sessionInfo() ## R version 4.0.3 (2020-10-10) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Arch Linux ## ## Matrix products: default ## BLAS: /usr/lib/libblas.so.3.9.0 ## LAPACK: /usr/lib/liblapack.so.3.9.0 ## ## locale: ## [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 LC_COLLATE=C ## [5] LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 ## [7] LC_PAPER=en_US.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C ## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices datasets utils grid methods ## [8] base ## ## other attached packages: ## [1] bookdown_0.21 SDMTools_1.1-221.2 sp_1.4-5 ## [4] formattable_0.2.0.1 ff_4.0.4 bit_4.0.4 ## [7] bigmemory_4.5.36 ocedata_0.1.8 gdtools_0.2.3 ## [10] oce_1.2-0 gsw_1.0-5 testthat_3.0.1 ## [13] fields_11.6 spam_2.6-0 dotCall64_1.0-0 ## [16] ncdf4_1.17 colorout_1.2-2 ## ## loaded via a namespace (and not attached): ## [1] tinytex_0.28 xfun_0.20 lattice_0.20-41 ## [4] vctrs_0.3.6 htmltools_0.5.0 yaml_2.2.1 ## [7] rlang_0.4.10 R.oo_1.24.0 pillar_1.4.7 ## [10] glue_1.4.2 R.utils_2.10.1 lifecycle_0.2.0 ## [13] stringr_1.4.0 R.methodsS3_1.8.1 htmlwidgets_1.5.3 ## [16] evaluate_0.14 knitr_1.30 callr_3.5.1 ## [19] ps_1.5.0 crosstalk_1.1.0.1 highr_0.8 ## [22] Rcpp_1.0.6 readr_1.4.0 DT_0.17 ## [25] magick_2.5.2 webshot_0.5.2 jsonlite_1.7.2 ## [28] systemfonts_0.3.2 hms_0.5.3 digest_0.6.27 ## [31] stringi_1.5.3 processx_3.4.5 tools_4.0.3 ## [34] magrittr_2.0.1 maps_3.3.0 tibble_3.0.5 ## [37] crayon_1.3.4 bigmemory.sri_0.1.3 pkgconfig_2.0.3 ## [40] ellipsis_0.3.1 rmarkdown_2.6 svglite_1.2.3.2 ## [43] rstudioapi_0.13 R6_2.5.0 compiler_4.0.3 "],["notes.html", "Chapter 1 Notes 1.1 Code-folding button", " Chapter 1 Notes Build the book: bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::gitbook&quot;) bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::pdf_book&quot;) bookdown::render_book(&quot;index.Rmd&quot;, &quot;all&quot;) # builds all outputs defined in _output.yml Build a specific chapter only: bookdown::preview_chapter(&quot;chapter.Rmd&quot;, &quot;bookdown::gitbook&quot;) Auto-update view in browser (http://127.0.0.1:4321) when saving a .Rmd file (from here). To stop the server, run servr::daemon_stop(\"140206388818696\") or restart your R session: bookdown::serve_book(dir=&quot;.&quot;, output_dir=&quot;_book&quot;, preview=TRUE, in_session=TRUE, quiet=FALSE, ...) Cache time consuming code chunks not to run them in every new knit ```{r important-computing, cache=T} Run a script ```{r code=readLines(&quot;myscript.R&quot;)} Create bib entries from a package: knitr::write_bib(c(&quot;knitr&quot;, &quot;stringr&quot;), &quot;&quot;, width = 60) In labels, no . signs are allowed! 1.1 Code-folding button This button is based on https://stackoverflow.com/questions/45360998/code-folding-in-bookdown https://github.com/twbs/bootstrap/tree/v3.3.7/js https://github.com/rstudio/bookdown/issues/395 "],["seawater-properties.html", "Chapter 2 Seawater properties 2.1 gravitational acceleration 2.2 heat capacity of seawater 2.3 speed of sound", " Chapter 2 Seawater properties if (file.exists(“~/data/woa/2018/woa18_decav_t00_04.nc”) &amp;&amp; file.exists(“~/data/woa/2018/woa18_decav_t00_04.nc”)) { } # if woa data exists 2.1 gravitational acceleration Fig. 2.1 shows the influence of latitude and pressure \\(p\\) on gravitational acceleration \\(g\\). library(gsw) lats &lt;- seq(0, 90, l=100) p &lt;- seq(0, 6000, l=100) g &lt;- outer(lats, p, function(x,y) gsw::gsw_grav(latitude=x, p=y)) g_rel_to_981 &lt;- g/9.81*100 - 100 par(mfrow=c(1, 2), mar=c(5, 6, 4, 2)) plot(lats, p, t=&quot;n&quot;, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, ylim=c(max(p), min(p)), xlab=&quot;Latitude [°]&quot;, ylab=NA, xaxs=&quot;i&quot;, yaxs=&quot;i&quot;) axis(1, at=pretty(lats, n=10)) axis(2, at=pretty(p, n=10), las=2) mtext(&quot;Depth [dbar]&quot;, side=2, line=4) abline(v=45, col=&quot;gray&quot;) contour(lats, p, g, levels=pretty(g, n=10), labcex=1, add=T) contour(lats, p, g, levels=9.81, col=&quot;red&quot;, add=T, drawlabels=F) plot(lats, p, t=&quot;n&quot;, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, ylim=c(max(p), min(p)), xlab=&quot;Latitude [°]&quot;, ylab=NA, xaxs=&quot;i&quot;, yaxs=&quot;i&quot;) axis(1, at=pretty(lats, n=10)) axis(2, at=pretty(p, n=10), las=2) mtext(&quot;Depth [dbar]&quot;, side=2, line=4) abline(v=45, col=&quot;gray&quot;) contour(lats, p, g_rel_to_981, levels=pretty(g_rel_to_981, n=10), labels=pretty(g_rel_to_981, n=10), labcex=1, add=T) Fig. 2.1: Gravitational acceleration \\(g\\) as a function of latitude and pressure \\(p\\) (in m s\\(^{-2}\\), left) and relative to 9.81 m s\\(^{-2}\\) (in %, right). 2.2 heat capacity of seawater Fig. 2.2 shows the influence of in-situ temperature \\(t\\) and absolute salinity \\(S_A\\) on heat capacity of seawater \\(c_\\text{p}\\) at different pressure \\(p\\) levels. cp0 &lt;- 3991.86795711963 # J/(kg K); from GSW-R/src/gsw_internal_const.h p &lt;- c(0, 1000, 2000, 4000) SA &lt;- seq(0, 40, l=100) t_insitu &lt;- seq(-2, 30, l=100) cps &lt;- array(NA, dim=c(length(SA), length(SA), length(p))) for (i in 1:length(p)) { cps[,,i] &lt;- outer(SA, t_insitu, function(x,y) gsw::gsw_cp_t_exact(SA=x, t=y, p=p[i])) } zlim &lt;- range(cps, na.rm=T) zat &lt;- pretty(zlim, n=15) cps_rel &lt;- cps/cp0*100 - 100 zlim_rel &lt;- range(cps_rel, na.rm=T) zat_rel &lt;- pretty(zlim_rel, n=15) par(mfrow=c(length(p), 2), mar=c(5, 6, 4, 2)) xat &lt;- pretty(t_insitu, n=15) yat &lt;- pretty(SA, n=15) for (i in 1:length(p)) { # absolute plots plot(t_insitu, SA, t=&quot;n&quot;, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, xlab=&quot;In-situ temperature [°C]&quot;, ylab=NA, xaxs=&quot;i&quot;, yaxs=&quot;i&quot;) abline(v=xat, col=&quot;gray&quot;, lwd=0.5) abline(h=yat, col=&quot;gray&quot;, lwd=0.5) axis(1, at=xat) axis(2, at=yat, las=2) mtext(&quot;Absolute salinity [g/kg]&quot;, side=2, line=4) contour(t_insitu, SA, cps[,,i], levels=zat, labcex=1, add=T) contour(t_insitu, SA, cps[,,i], levels=cp0, labcex=1, col=&quot;red&quot;, add=T) legend(&quot;topright&quot;, paste0(p[i], &quot; dbar&quot;), lty=NA, pch=NA, lwd=NA, bty=&quot;n&quot;) # relative plots plot(t_insitu, SA, t=&quot;n&quot;, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, xlab=&quot;In-situ temperature [°C]&quot;, ylab=NA, xaxs=&quot;i&quot;, yaxs=&quot;i&quot;) abline(v=xat, col=&quot;gray&quot;, lwd=0.5) abline(h=yat, col=&quot;gray&quot;, lwd=0.5) axis(1, at=xat) axis(2, at=yat, las=2) mtext(&quot;Absolute salinity [g/kg]&quot;, side=2, line=4) contour(t_insitu, SA, cps_rel[,,i], levels=zat_rel, labels=zat_rel, labcex=1, add=T) legend(&quot;topright&quot;, paste0(p[i], &quot; dbar&quot;), lty=NA, pch=NA, lwd=NA, bty=&quot;n&quot;) } Fig. 2.2: Heat capacity of seawater \\(c_p\\) as a function of in-situ temperature \\(t\\) and absolute salinity \\(S_A\\) (in m\\(^2\\) s\\(^{-2}\\) K\\(^{-1}\\), left) and relative to \\(c_{p,0}\\) = 3991.86795711963 m\\(^2\\) s\\(^{-2}\\) K\\(^{-1}\\) (in %, right) at different depths. 2.3 speed of sound Fig. 2.3 shows the influence of in-situ temperature \\(t\\) and absolute salinity \\(S_A\\) on speed of sound \\(c\\) at different pressure \\(p\\) levels. p &lt;- c(0, 1000, 2000, 4000) SA &lt;- seq(0, 40, l=100) t_insitu &lt;- seq(-2, 30, l=100) soss &lt;- array(NA, dim=c(length(SA), length(SA), length(p))) for (i in 1:length(p)) { soss[,,i] &lt;- outer(SA, t_insitu, function(x,y) gsw::gsw_sound_speed_t_exact(SA=x, t=y, p=p[i])) } zlim &lt;- range(soss, na.rm=T) zat &lt;- pretty(zlim, n=15) sos0 &lt;- mean(soss, na.rm=T) soss_rel &lt;- soss/sos0*100 - 100 zlim_rel &lt;- range(soss_rel, na.rm=T) zat_rel &lt;- pretty(zlim_rel, n=15) par(mfrow=c(length(p), 2), mar=c(5, 6, 4, 2)) xat &lt;- pretty(t_insitu, n=15) yat &lt;- pretty(SA, n=15) for (i in 1:length(p)) { # absolute plots plot(t_insitu, SA, t=&quot;n&quot;, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, xlab=&quot;In-situ temperature [°C]&quot;, ylab=NA, xaxs=&quot;i&quot;, yaxs=&quot;i&quot;) abline(v=xat, col=&quot;gray&quot;, lwd=0.5) abline(h=yat, col=&quot;gray&quot;, lwd=0.5) axis(1, at=xat) axis(2, at=yat, las=2) mtext(&quot;Absolute salinity [g/kg]&quot;, side=2, line=4) contour(t_insitu, SA, soss[,,i], levels=zat, labcex=1, add=T) contour(t_insitu, SA, soss[,,i], levels=sos0, labcex=1, col=&quot;red&quot;, add=T) legend(&quot;topright&quot;, paste0(p[i], &quot; dbar&quot;), lty=NA, pch=NA, lwd=NA, bty=&quot;n&quot;) # relative plots plot(t_insitu, SA, t=&quot;n&quot;, xaxt=&quot;n&quot;, yaxt=&quot;n&quot;, xlab=&quot;In-situ temperature [°C]&quot;, ylab=NA, xaxs=&quot;i&quot;, yaxs=&quot;i&quot;) abline(v=xat, col=&quot;gray&quot;, lwd=0.5) abline(h=yat, col=&quot;gray&quot;, lwd=0.5) axis(1, at=xat) axis(2, at=yat, las=2) mtext(&quot;Absolute salinity [g/kg]&quot;, side=2, line=4) contour(t_insitu, SA, soss_rel[,,i], levels=zat_rel, labels=zat_rel, labcex=1, add=T) legend(&quot;topright&quot;, paste0(p[i], &quot; dbar&quot;), lty=NA, pch=NA, lwd=NA, bty=&quot;n&quot;) } Fig. 2.3: Speed of sound \\(c\\) as a function of in-situ temperature \\(t\\) and absolute salinity \\(S_A\\) (in m s\\(^{-1}\\), left) and relative to \\(c_0\\) = 1510 m s\\(^{-1}\\) (in %, right) at different depths. "],["bigmemory-and-ff.html", "Chapter 3 bigmemory and ff 3.1 Regular data example 3.2 Irregular data example", " Chapter 3 bigmemory and ff 3.1 Regular data example For testing, load the 1\\(^\\circ\\) World Ocean Atlas (Levitus) SST [sea surface temperature; Locarnini et al. (2013)] and SSS [sea surface salinity; Zweng et al. (2013)] data via the oceadata package (D. Kelley 2019). library(ocedata) data(levitus, package=&quot;ocedata&quot;) str(levitus) # the data is filled with NA at land ## List of 4 ## $ longitude: num [1:360] -180 -178 -178 -176 -176 ... ## $ latitude : num [1:180] -89.5 -88.5 -87.5 -86.5 -85.5 -84.5 -83.5 -82.5 -81.5 -80.5 ... ## $ SSS : num [1:360, 1:180] NA NA NA NA NA NA NA NA NA NA ... ## $ SST : num [1:360, 1:180] NA NA NA NA NA NA NA NA NA NA ... From this, create bigmemory (Kane et al. 2018) and ff (Adler et al. 2018) objects. sst_base &lt;- levitus$SST # the default format from base package library(bigmemory) sst_bm &lt;- bigmemory::as.big.matrix(levitus$SST) # bigmemory format library(ff) sst_ff &lt;- ff::as.ff(levitus$SST) # ff format c(identical(sst_base, sst_bm[,]), # note the different index syntax [,] identical(sst_base, sst_ff[,])) ## [1] TRUE TRUE str(sst_base) ## num [1:360, 1:180] NA NA NA NA NA NA NA NA NA NA ... str(describe(sst_bm)) ## Formal class &#39;big.matrix.descriptor&#39; [package &quot;bigmemory&quot;] with 1 slot ## ..@ description:List of 12 ## .. ..$ sharedType: chr &quot;SharedMemory&quot; ## .. ..$ sharedName: chr &quot;kFLGsOBJTrrLrBsBtuNmnFhw&quot; ## .. ..$ totalRows : int 360 ## .. ..$ totalCols : int 180 ## .. ..$ rowOffset : num [1:2] 0 360 ## .. ..$ colOffset : num [1:2] 0 180 ## .. ..$ nrow : num 360 ## .. ..$ ncol : num 180 ## .. ..$ rowNames : NULL ## .. ..$ colNames : NULL ## .. ..$ type : chr &quot;double&quot; ## .. ..$ separated : logi FALSE str(virtual(sst_ff)) ## List of 4 ## $ Length : int 64800 ## $ Dim : int [1:2] 360 180 ## $ Dimorder : int [1:2] 1 2 ## $ Symmetric: logi FALSE The sizes of the three different SST objects highlight the large difference between the standard base compared to the bigmemory and ff packages in terms of memory usage (see my adapted form of Dirk Eddelbuettel’s lsos() function here): #DT::datatable(myls(pattern=&quot;sst&quot;), options=list(dom=&#39;t&#39;)) #df &lt;- myls(pattern=&quot;sst&quot;) df &lt;- structure(list(Type = structure(3:1, .Label = c(&quot;big.matrix&quot;, &quot;ff_matrix&quot;, &quot;matrix&quot;), class = &quot;factor&quot;), `Size [B]` = c(518616, 3504, 696), PrettySize = structure(c(2L, 1L, 3L), .Label = c(&quot;3.4 Kb&quot;, &quot;506.5 Kb&quot;, &quot;696 bytes&quot;), class = &quot;factor&quot;), RelSize = c(1, 0.007, 0.001), dim1 = c(360, 360, 360), dim2 = c(180, 180, 180)), row.names = c(&quot;sst_base&quot;, &quot;sst_ff&quot;, &quot;sst_bm&quot;), class = &quot;data.frame&quot;) library(formattable) ft &lt;- formattable::formattable(df, list( RelSize=formattable::formatter(&quot;span&quot;, style=function(x) { formattable::style(display=&quot;inline-block&quot;, direction=&quot;ltr&quot;, &quot;border-radius&quot;=&quot;4px&quot;, &quot;background-color&quot;=&quot;#b8dff3&quot;, width=formattable::percent(x)) }))) formattable::as.datatable(ft, options=list(dom=&#39;t&#39;)) Manipulations of the bigmemory and ff objects can be obtained as with base. For example, the area-averaged SST can be calculated for all data points within or on the edge of an arbitrary polygon (see Fig. 3.1). library(sp) # for point.in.polygon() poly &lt;- list(x=c(-30, -75, -30, -15, -30), # deg longitude y=c(60, 30, 0, 30, 60)) # deg latitude lon &lt;- levitus$longitude lat &lt;- levitus$latitude xy &lt;- expand.grid(lon, lat, KEEP.OUT.ATTRS=F) colnames(xy) &lt;- c(&quot;x&quot;, &quot;y&quot;) inds &lt;- sp::point.in.polygon(xy$x, xy$y, poly$x, poly$y) # returns indices as vector, not matrix inds &lt;- which(inds == 1 | inds == 2) # inside or on edge of polygon 1800 (length(inds)) out of 64800 (dim(xy)[1]) 1\\(^\\circ\\) data points are located within or on the edge of poly (note that in this example the indices would be the same if only the ones completely within were considered, i.e. inds == 1). Fig. 3.1 shows the SST data and the obtained points in orthographic projection and was realized with the oce package (D. Kelley and Richards 2018). More information on available projections can be found by vignette(\"oce\"), ?oce::mapPlot or in Appendix C of D. E. Kelley (2018). The plot was generated like this: library(oce) # for mapPlot() etc. library(fields) # for colorbar via image.plot() # make colorbar zlim &lt;- range(sst_base, na.rm=T) breaks &lt;- pretty(zlim) cm &lt;- oce::colormap(breaks=breaks, col=oce::oce.colorsPalette(length(breaks)-1)) if (T) { png(&quot;test.png&quot;, width=8.267717, height=11.69291, units=&quot;in&quot;, res=300) #pdf(&quot;test.pdf&quot;, width=8.267717, height=11.69291) } # define projection p &lt;- &quot;+proj=ortho +lat_0=30 +lon_0=-45&quot; # orthographic projection # open plot device and set margins #par(mar=c(0, 0, 0, 5), oma=c(0, 0, 0, 0)) # larger right margin for colorbar par(mar=c(0, 0, 0, 0), oma=c(0, 0, 0, 0)) # larger right margin for colorbar # set coordinate system oce::mapPlot(xy$x, xy$y, projection=p, grid=T, #type=&quot;n&quot;, longitudelim=c(-95, -5), latitudelim=c(20, 90), axes=F, drawBox=F) # color everything in gray for land oce::mapImage(levitus$longitude, levitus$latitude, array(1, dim(sst_base)), col=&quot;gray66&quot;) # add the data with colors oce::mapImage(levitus$longitude, levitus$latitude, sst_base, breaks=cm$breaks, filledContour=F, gridder=NA) # add breaks as contour lines oce::mapContour(levitus$longitude, levitus$latitude, sst_base, levels=cm$breaks, lwd=0.75) # add grid lines oce::mapGrid(dlongitude=15, dlatitude=10, polarCircle=5, col=&quot;black&quot;, lwd=0.5) # add our arbitrary polygon (project piece-wise) for (i in 1:(length(poly$x) - 1)) { tmp &lt;- oce::lonlat2map(seq(poly$x[i], poly$x[i+1], l=100), seq(poly$y[i], poly$y[i+1], l=100), projection=p) lines(tmp, lwd=1.5) } # for i points # add points within/on the edge of our arbitrary polygon tmp &lt;- oce::lonlat2map(xy$x[inds], xy$y[inds], projection=p) points(tmp, pch=&quot;.&quot;) # add colorbar fields::image.plot(zlim=zlim, legend.only=T, lwd=0.5, breaks=cm$breaks, col=cm$col, legend.mar=par(&quot;mar&quot;)[4] + 1) mtext(text=&quot;SST [°C]&quot;, side=4, line=par(&quot;mar&quot;)[4] - 2) Fig. 3.1: Average (1955-2012) SST [in °C; colors; no data at gray areas; Locarnini et al. (2013)] plotted in orthographic projection with the oce package (D. Kelley and Richards 2018). Black dots mark the center of all data matrix elements within or on the edge of the arbitrary polygon poly shown by the thick black line. A subset of the data within the polygon can be obtained from the bigmemory and ff objects by integer indexing as for the default base object. Remember that the returned indices by sp::point.in.polygon() are a vector of nlon*nlat length, not a nlon \\(\\times\\) nlat dimensioned matrix. That means the data needs to be converted from a 2D matrix to a 1D vector before selecting elements via inds. sst_vec_base &lt;- as.vector(sst_base) sst_sub_base &lt;- sst_vec_base[inds] sst_vec_bm &lt;- bigmemory::as.big.matrix(sst_vec_base) sst_sub_bm &lt;- bigmemory::as.big.matrix(sst_vec_bm[][inds]) sst_vec_ff &lt;- ff::as.ff(sst_vec_base) sst_sub_ff &lt;- sst_vec_ff[ff::as.ff(inds)] c(identical(sst_sub_base, sst_sub_bm[]), identical(sst_sub_base, sst_sub_ff[])) ## [1] TRUE TRUE Now, the average SST within the polygon can be calculated by, for example, the area \\(A\\) -weighted arithmetic mean \\(\\mu_\\text{SST} = (\\sum_i A_i)^{-1} \\, \\sum_i (A_i \\cdot \\text{SST}_i)\\), with \\(i = (1, \\dots, 1800)\\): library(SDMTools) # for grid.info() area_m2 &lt;- grid.info(lats=lat, cellsize=diff(lon)[1])$area # bring on same format as the y dimension of the xy vector area_m2 &lt;- rep(area_m2, e=length(lon)) # select within/on the edge of our arbitrary polygon area_m2 &lt;- area_m2[inds] # set potential NA values also in the area_m2 vector if (any(is.na(sst_sub_base))) { area_m2[is.na(sst_sub_base)] &lt;- NA } sst_mean_base &lt;- sum(sst_sub_base*area_m2, na.rm=T)/sum(area_m2, na.rm=T) sst_mean_bm &lt;- sum(sst_sub_bm[]*area_m2, na.rm=T)/sum(area_m2, na.rm=T) sst_mean_ff &lt;- sum(sst_sub_ff[]*area_m2, na.rm=T)/sum(area_m2, na.rm=T) # todo: esd::aggregate.area(x,is=NULL,it=NULL,FUN=’sum’,na.rm=TRUE,smallx=FALSE) c(sst_mean_base, sst_mean_bm, sst_mean_ff) ## [1] 22.03309 22.03309 22.03309 c(identical(sst_mean_base, sst_mean_bm), identical(sst_mean_base, sst_mean_ff)) ## [1] TRUE TRUE Compare this result to cdo fldmean: # save the sst field as nc file lon_dim &lt;- ncdim_def(name=&quot;lon&quot;, units=&quot;&quot;, vals=lon) lat_dim &lt;- ncdim_def(name=&quot;lat&quot;, units=&quot;&quot;, vals=lat) sst_var &lt;- ncvar_def(name=&quot;sst&quot;, units=&quot;degC&quot;, dim=list(lon_dim, lat_dim), missval=NA, prec=&quot;double&quot;) outnc &lt;- nc_create(&quot;sst_wout_grid.nc&quot;, vars=sst_var, force_v4=T) ncvar_put(outnc, sst_var, sst_base) nc_close(outnc) # set a proper grid description for cdo system(&quot;cdo -setgrid,woa_1deg_griddes sst_wout_grid.nc sst.nc&quot;) # note: woa_1deg_griddes is obtained from &#39;cdo griddes woa18_decav_t00_01.nc&#39; # https://www.nodc.noaa.gov/OC5/woa13/woa13data.html cat(system(&quot;cdo griddes sst.nc | head -7 | tail -4&quot;, intern=T), sep=&quot;\\n&quot;) ## gridtype = lonlat ## gridsize = 64800 ## xsize = 360 ## ysize = 180 # save our arbitrary polygon write.table(poly, file=&quot;poly.txt&quot;, row.names=F, col.names=F) cat(system(&quot;cat poly.txt&quot;, intern=T), sep=&quot;\\n&quot;) ## -30 60 ## -75 30 ## -30 0 ## -15 30 ## -30 60 # apply the polygon and calculate the cdo field mean system(&quot;cdo -maskregion,poly.txt sst.nc sst_mask.nc&quot;) # need to remove already existing file; dont know why system(&quot;rm sst_mean_cdo.nc&quot;) system(&quot;cdo -fldmean sst_mask.nc sst_mean_cdo.nc&quot;) # load the result in R workspace ncin &lt;- nc_open(&quot;sst_mean_cdo.nc&quot;) sst_mean_cdo &lt;- ncvar_get(ncin, &quot;sst&quot;) sst_mean_cdo ## [1] 22.03309 identical(sst_mean_base, sst_mean_cdo) ## [1] FALSE Whops, the R and cdo results are not the same? They are, but differ after the 12th decimal postion: print(sst_mean_base, digits=20) ## [1] 22.033094656022573332 print(sst_mean_cdo, digits=20) ## [1] 22.033094656022782942 sst_mean_base - sst_mean_cdo ## [1] -2.096101e-13 In conclusion, for the tested base, bigmemory and ff objects, the area-averaged SST within the polygon (total area \\(\\sim\\) 19 \\(\\times\\) 106 km2; Fig. 3.1) \\(\\mu_\\text{SST}\\) = 22.0330947 \\(^\\circ\\)C (the same result is obtained with cdo fldmean). This is a multi-line latex equation example: \\[\\begin{align} \\begin{split} &amp; \\text{RF} &amp; = \\quad \\alpha \\, \\ln \\left( \\frac{\\text{C}}{\\text{C}_0} \\right) \\\\ \\Leftrightarrow \\quad &amp; \\text{C}_0 \\, \\exp \\left( \\frac{\\text{RF}}{\\alpha} \\right) \\quad &amp; = \\quad \\text{C} \\,, \\end{split} \\tag{3.1} \\end{align}\\] 3.2 Irregular data example "],["references.html", "References", " References Adler, Daniel, Christian Gläser, Oleg Nenadic, Jens Oehlschlägel, and Walter Zucchini. 2018. Ff: Memory-Efficient Storage of Large Data on Disk and Fast Access Functions. https://CRAN.R-project.org/package=ff. Kane, Michael J., John W. Emerson, Peter Haverty, and Charles Determan Jr. 2018. Bigmemory: Manage Massive Matrices with Shared Memory and Memory-Mapped Files. https://CRAN.R-project.org/package=bigmemory. Kelley, D. E. 2018. Oceanographic Analysis with R. Springer Science+Business Media. Kelley, Dan. 2019. Ocedata: Oceanographic Data Sets for ’Oce’ Package. https://dankelley.github.io/ocedata. Kelley, Dan, and Clark Richards. 2018. Oce: Analysis of Oceanographic Data. https://CRAN.R-project.org/package=oce. Locarnini, R. A., A. V. Mishonov, J. I. Antonov, T. P. Boyer, H. E. Garcia, O. K. Baranova, M. M. Zweng, et al. 2013. World Ocean Atlas 2013, Volume 1: Temperature. S. Levitus. Ed., A. Mishonov technical editor, NOAA Atlas NESDIS 73. Zweng, M. M., J. R. Reagan, J. I. Antonov, R. A. Locarnini, A. V. Mishonov, T. P. Boyer, H. E. Garcia, et al. 2013. World Ocean Atlas 2013, Volume 2: Salinity. S. Levitus. Ed., A. Mishonov technical editor, NOAA Atlas NESDIS 74. "]]
